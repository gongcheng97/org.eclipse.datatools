SELECT * FROM TBKT2102 ORDER BY DATE2, TIMESTAMP2, SORT_FIELD;

SELECT DATE2, TIMESTAMP2, SORT_FIELD
       FROM TBKT2101 ORDER BY DATE2, TIMESTAMP2, SORT_FIELD;

------              ABS FUNCTION
--------STMT1
SELECT ABS(INTCOLNN)
FROM VWKT2102
WHERE ABS(INTCOLNN) = INTCOLNN;

--------STMT5
SELECT ABS(INTCOLWDN)
FROM VWKT2102 WHERE RECID='959';

--------STMT10
SELECT ABS(INTCOLWDN)
FROM VWKT2102
WHERE ABS(INTCOLWDN) IS NULL;

--------STMT15
SELECT ABS(LVCHAR)
FROM VWKT2102
WHERE ABS(LVCHAR) = LVCHAR;

--------STMT20
SELECT ABS(SMINT)
FROM VWKT2102
WHERE ABS(SMINT) = SMINT;

--------STMT45
SELECT IFNULL(FLOAT4WDN,FLOAT4WDN)
FROM VWKT2102
WHERE ABS(DOUBLE(FLOAT4NN)) = DOUBLE(FLOAT4NN);

--------STMT55
--* VALID DATATYPE:  SINGLE-PRECISION FLOATING POINT
--* KEY POINTS:      ABS AND IFNULL IN SELECT AND WHERE
--*                  CLAUSE WITH DOUBLE FUNCTION AND
--*                  DEFAULT NULL
SELECT IFNULL(FLOAT4WDN,FLOAT4WDN)
FROM VWKT2102
WHERE ABS(FLOAT4WDN) = FLOAT4WDN;

--------*STMT57*********************************************
--* VALID DATATYPE:  SINGLE-PRECISION FLOATING POINT
--* KEY POINTS:      ABS AND IFNULL IN SELECT AND WHERE
--*                  CLAUSE WITH NESTED DOUBLE FUNCTION
--*                  AND DEFAULT NULL
SELECT ABS(ABS(ABS(ABS(ABS(ABS(ABS(ABS(ABS(-FLOAT4WDN)))))))))
FROM VWKT2102
WHERE ABS(ABS(ABS(FLOAT4WDN))) = ABS(-FLOAT4WDN);

--------*STMT60*********************************************
--* VALID DATATYPE:  DOUBLE-PRECISION FLOATING POINT
--* KEY POINTS:      ABS AND IFNULL IN SELECT AND WHERE
--*                  CLAUSE WITH DOUBLE FUNCTION
SELECT ABS(IFNULL(FLOAT4WDN,FLOAT4WDN))
FROM VWKT2102
WHERE ABS(FLOAT(FLOAT4NN)) = FLOAT(FLOAT4NN);

--------*STMT65*********************************************
--* VALID DATATYPE:  DOUBLE-PRECISION FLOATING POINT
--* KEY POINTS:      ABS AND IFNULL IN SELECT AND WHERE
--*                  CLAUSE OF FULLSELECT WITH
--*                  DEFAULT NULL.
SELECT ABS(IFNULL(FLOAT4WDN,FLOAT4WDN))
FROM VWKT2102 WHERE ABS(FLOAT4WDN) IS NULL;

--------*STMT70*********************************************
--* VALID DATATYPE:  INTEGER
--* KEY POINTS:      ABS AND HEX IN SELECT AND WHERE
--*                  CLAUSE OF FULLSELECT
SELECT ABS(HEX(INTCOLNN))
FROM VWKT2102 WHERE ABS(HEX(INTCOLNN)) = INTCOLNN;

--------*STMT70*********************************************
--* VALID DATATYPE:  ABS, IFNULL
--* KEY POINTS:      IFNULL IN SELECT/FROM/WHERE CLAUSE OF
--*                    NESTED TABLE EXPRESSION AND SUBSELECT
--*                    WITH CORRELATED QUERY
SELECT ABS(IFNULL((FLOAT(IFNULL(FLOAT(RECID),0))) /
             (IFNULL(FLOAT(FILENO)+1,0)),0))
FROM (SELECT A.RECID, B.FILENO, A.FLOAT4WDN, B.FLOAT8, A.FLOAT4NN,
           B.INTCOLWDN,A.VARCHAR20BIT,A.INTCOLNN,A.DEFNULL
              FROM VWKT2102 A, TBKT2102 B
       WHERE A.RECID = '001') AS TBK001
 WHERE CASE
         WHEN ABS(IFNULL(123.00*2,0.00000))
           =  ABS(IFNULL(FLOAT4WDN,123.00*2.0))  THEN 1
         WHEN ABS(IFNULL(REAL(123.0*2.0),0))
           =  ABS(IFNULL(INTEGER(FLOAT(1000)),0))            THEN 2
         WHEN ABS(INTEGER((FLOAT4NN+1.0-2.)*.1))
           >= ABS(INTEGER(INTCOLNN))       THEN 6
         WHEN ABS(IFNULL(SMALLINT(RECID),0))
           =  ABS(IFNULL(INTCOLWDN,INTEGER(FILENO)))         THEN 3
         WHEN ABS(IFNULL(SMALLINT(RECID),0))
           <  ABS(IFNULL(INTCOLWDN,INTEGER(FILENO)))          THEN 4
         WHEN ABS(IFNULL(SMALLINT(RECID),0))
           >  ABS(IFNULL(INTCOLWDN,INTEGER(FILENO)))          THEN 5
       ELSE 7 END IN (0,1,2,3,4,5,6);

--------*STMT95********************************************
--* VALID DATATYPE:  CHAR
--* KEY POINTS:      VARCHAR IN SELECT/WHERE CLAUSE OF FULLSELECT
--*                    WITH SIMPLE-WHEN CLAUSE OF CASE STMT
SELECT
   CASE
       WHEN ABS(VARCHAR(FILENO))
        >  VARCHAR(RECID) THEN ABS(SMALLINT(-9))
       WHEN VARCHAR(FILENO)
        <  VARCHAR(RECID) THEN ABS(SMALLINT(-1))
       WHEN VARCHAR(FILENO)
        = VARCHAR(RECID) THEN ABS(INT(SMALLINT(RECID)/SMALLINT(FILENO)))
   END
 FROM   TBKT2102;

--------*STMT100********************************************
--* VALID DATATYPE:  DATE, TIMESTAMP
--* KEY POINTS:      ABS OF DATE, TIMESTAMP, DAYOFYEAR FUNCTION
--*                  IN SELECT AND WHERE CLAUSE OF FULLSELECT,
--*                  WITH DATE ARGUMENT
SELECT ABS(DAYOFWEEK(TIMESTMP)),ABS(DAYOFMONTH(TIMESTMP)),
       ABS(DAYOFYEAR(TIMESTMP))
FROM VWKT2102
WHERE RECID = '001'
  AND ABS(DAYOFWEEK(DATE(CURRENT TIMESTAMP))) =
  ABS(DAYOFWEEK(DATE(CURRENT DATE)))
  AND ABS(DAYOFMONTH(DATE(CURRENT TIMESTAMP))) =
  ABS(DAYOFMONTH(CURRENT DATE))
  AND ABS(DAYOFYEAR(DATE(CURRENT TIMESTAMP))) =
  ABS(DAYOFYEAR(DATE(CURRENT TIMESTAMP)));

--------*STMT110********************************************
--* VALID DATATYPE:  DECIMAL
--* KEY POINTS:      CONCAT IN SELECT AND WHERE CLAUSE OF
--*                  FULLSELECT
 SELECT
   CASE
     WHEN ABS(DECIMAL(CONCAT(RECID,'0')))
       =  ABS(DECIMAL(FILENO || '0'))              THEN ABS(1)
     WHEN ABS(DECIMAL(CONCAT(RECID,'0')))
       <  ABS(DECIMAL(FILENO || '0'))              THEN ABS(-1)
     WHEN ABS(DECIMAL(CONCAT(RECID,'0')))
       >  ABS(DECIMAL(FILENO || '0'))              THEN ABS(-9)
   END
 FROM   TBKT2102;

--------*STMT125********************************************
--* VALID DATATYPE:  INTEGER, FLOAT, DOUBLE, DECIMAL
--* KEY POINTS:      ABS, CEIL, FLOOR FUNCTION
--*                  IN FULLSELECT
 SELECT ABS(INT(DECIMAL(FLOAT(DOUBLE(CEIL(FLOOR(INTCOLNN)))))))
  FROM VWKT2102;

--------*STMT130********************************************
--* VALID DATATYPE:  INTEGER, FLOAT, DOUBLE, DECIMAL
--* KEY POINTS:      ABS, CEIL, FLOOR FUNCTION
--*                  IN SELECT OF FULLSELECT
--*                  AND SUBSELECT
 SELECT ABS(INT(DECIMAL(FLOAT(DOUBLE(CEIL(FLOOR(1)))))))
  FROM (SELECT INT(DECIMAL(FLOAT(DOUBLE(CEIL(FLOOR(INTCOLNN))))))
   FROM VWKT2102) AS TBKT002;

--------*STMT135********************************************
--* VALID DATATYPE:  INTEGER, FLOAT, DOUBLE, DECIMAL
--* KEY POINTS:      ABS, CEIL, FLOOR FUNCTION
--*                  IN SELECT OF FULLSELECT
--*                  AND WHERE CLAUSE OF FULLSELECT
  SELECT INT(DECIMAL(FLOAT(ABS(DOUBLE(CEIL(FLOOR(INTCOLNN)))))))
   FROM VWKT2102
  WHERE INT(DECIMAL(FLOAT(ABS(DOUBLE(CEIL(FLOOR(INTCOLNN))))))) =
   INT(DECIMAL(FLOAT(ABS(DOUBLE(CEIL(FLOOR(INTCOLNN)))))));

--------*STMT180********************************************
--* VALID DATATYPE:  FLOAT, SMALLINT, INTEGER
--* KEY POINTS:      ABS WITH SUM ON SELECT STATEMENT
--*                  WITH WHERE CLAUSE
SELECT ABS(SUM(FLOAT4NN+INTCOLNN+NUMERIC83NN+SMINT)) FROM TBKT2102
 WHERE RECID='969';

--------*STMT200********************************************
--* VALID DATATYPE:  FLOAT
--* KEY POINTS:      ABS WITH COUNT ON SELECT
--*                  WITH WHERE CLAUSE
SELECT ABS(COUNT(*)) FROM TBKT2102 WHERE
  ABS(FLOAT(FLOAT4NN)) = FLOAT4NN;

--------*STMT225********************************************
--* VALID DATATYPE:  SMALL INTEGER, INTEGER
--* KEY POINTS:      ABS, MIN IN SELECT/WHERE CLAUSE OF SUBSELECT
--*                  (2 LEVELS)
  SELECT ABS(MIN(SMINT)/MIN(SMINT))
  FROM VWKT2102
  WHERE ABS(SMALLINT(RECID)) = ABS(INTEGER(FILENO))
    AND ABS(SMALLINT(RECID)/SMALLINT(FILENO)) IN
        (SELECT ABS(SMALLINT(FLOAT8/FLOAT8))
         FROM TBKT2102
         WHERE RECID = CHAR(100)
        AND SMALLINT(RECID) <>
            (SELECT MIN(ABS(INTCOLNN))
             FROM TBKT2102
             WHERE ABS(INTCOLNN) = INTCOLNN));

--------*STMT230********************************************
--* VALID DATATYPE: INTEGER
--* KEY POINTS:     ABS IN DEEPLY NESTED TABLE EXPRESSION
--*                 WITH ARITHMETIC OPERATORS
SELECT * FROM (
  SELECT * FROM (
     SELECT * FROM (
        SELECT * FROM (
           SELECT * FROM (
              SELECT * FROM (
                 SELECT * FROM (
                   SELECT ABS(INTCOLNN)
                    FROM TBKT2101
                    WHERE RECID = '100'
                 ) AS TBLEXP6
              ) AS TBLEXP5
           ) AS TBLEXP4
        ) AS TBLEXP3
     ) AS TBLEXP2
  ) AS TBLEXP1
) AS TBLEXP0;


-- Case statement in a select, insert, update, delete statement

--**1**
SELECT * FROM HIPPO
  WHERE CASE POUNDS
          WHEN  6000 THEN 1
          WHEN  8090 THEN 2
          WHEN 10100 THEN 1
          WHEN 12050 THEN 2
          WHEN  1450 THEN 1
          ELSE 3
        END = 1;

--**3**
SELECT * FROM HIPPO
  WHERE CASE MOUTHS
          WHEN '061' THEN 'AAA'
          WHEN '010' THEN 'BBB'
          WHEN '118' THEN 'CCC'
          WHEN '087' THEN 'DDD'
          WHEN '000' THEN 'EEE'
          ELSE 'FFF'
        END > 'CCC';

--**5**
SELECT * FROM HIPPO
  WHERE CASE
          WHEN MOUTHS = '061' THEN CURRENT SERVER
          WHEN MOUTHS = '010' THEN USER
          WHEN MOUTHS = '118' THEN CURRENT SCHEMA
          WHEN MOUTHS = '087' THEN CURRENT SERVER
          WHEN MOUTHS = '000' THEN CURRENT DEGREE
          ELSE CURRENT PATH
        END IN (CURRENT SERVER, USER);

--**11**
SELECT POUNDS, MOUTHS FROM HIPPO
  WHERE MOUTHS IN (
    SELECT
      CASE
        WHEN MOUTHS = '061' THEN '000'
        WHEN MOUTHS = '010' THEN '087'
        WHEN MOUTHS = '118' THEN '118'
        WHEN MOUTHS = '087' THEN '010'
        WHEN MOUTHS = '000' THEN '061'
        ELSE '999'
      END
    FROM HIPPO);

--**14**
SELECT * FROM HIPPO WHERE EXISTS (
  SELECT CASE
           WHEN FOOD = 'FIRED APPLES' THEN 1
         END
    FROM HIPPO);

--**2**
 SELECT POUNDS,
        MOUTHS,
        CASE WHEN CASE WHEN LEGNO = 1111 THEN 0
                       WHEN LEGNO = 1110 THEN 1
                       ELSE 2
                  END = 0 THEN 9
             WHEN CASE LEGNO
                       WHEN 11   THEN 3
                       WHEN 1011 THEN 4
                       ELSE 5
                  END = 3 THEN 8
             ELSE 7
        END AS CASERESULT,
        FOOD
   FROM HIPPO;

--**4**
SELECT POUNDS,
       NULLIF(CASE
                WHEN FOOD = 'FRIED APPLES' THEN '061'
                ELSE '999'
              END,
              CASE
                WHEN FOOD = 'FRIED APPLES' THEN '061'
                ELSE '999'
              END) AS NULLIFRESULT,
       LEGNO,
       FOOD
  FROM HIPPO;

--**12**
SELECT POUNDS
  FROM HIPPO
    WHERE NULLIF(CASE
                   WHEN FOOD = 'FRIED APPLES'        THEN '061'
                   WHEN FOOD = 'PUMPKINS AND ROOTS'  THEN '010'
                   WHEN FOOD = 'LETTUCE AND CARROTS' THEN '118'
                   WHEN FOOD = 'CABBAGE AND RAISINS' THEN '087'
                   ELSE '999'
                 END,
                 MOUTHS) BETWEEN '061' AND '087';

--**2**
SELECT * FROM T1 X
  WHERE C1 IN (
    SELECT C1 FROM T2
      WHERE C2 = CASE X.C3
                   WHEN 3 THEN C1
                   WHEN 4 THEN C2
                 END);


-- Using a column reference in a select, update, delete statement

--* USE  DERIVED VIEW COLUMNS IN COLUMN FUNCTIONS USING GROUP BY,
--* HAVING AND ORDER  BY CLAUSES AND USE INDEXES.
--* THERE IS AN INDEX ON EMPNUM SINCE THIS COLUMN WAS DERIVED FROM
--* THE UNIQUE KEY SERIALNO IN TBEN4501
--* THERE IS ALSO AN INDEX ON WORKLOC, AND COUNTRY IS DERIVED FROM
--* THAT COLUMN.
  SELECT COUNTRY, MAX(HIREAGE), MIN(TOTSAL)
    FROM VWEN4501
      WHERE EMPNUM BETWEEN 3000 AND 5000
      GROUP BY COUNTRY
      HAVING COUNT(*) > 4
    ORDER BY 2 DESC;

--* THIS SHOULD SHOW THAT THE DELETE GOT RID OF TWO ROWS.
--* NO ROWS SHOULD SHOW FOR SERIAL NUMBERS 5098 OR 6854
SELECT CONSTCOL, BUSINESS
  FROM VWEN4504
  GROUP BY BUSINESS, CONSTCOL
  HAVING AVG(COST) > CONSTCOL AND
         MAX(COST) IN (SELECT VC4 FROM VWEN4504
                         GROUP BY VC4
                         HAVING COUNT(*) > 10)
ORDER BY BUSINESS;

--* USES DERIVED VIEW COLUMNS IN COLUMN FUNCTIONS USING GROUP BY,
--* HAVING AND ORDER  BY CLAUSES AND USES INDEX ON SERIALNO.
--* UNION ALL IS USED WITH THE ORDER BY CLAUSE. EXPRESSION  INVOLVING
--* MORE THAN ONE DERIVED COLUMN IS USED. DERIVED NULL COLUMNS ARE USED
--* FIRST SELECT OF UNION RESULTS IN 6 ROWS (COUNTRY = USA AND EMPNUM
--* BETWEEN 2000 AND 3000)
--* 2ND SELECT OF UNION RESULTS IN 2 ROWS (2478 AND 2909)
--* 3RD SELECT RESULTS IN SIX ROWS
  SELECT EMPNUM FROM VWEN4501
    WHERE COUNTRY IN (SELECT COUNTRY FROM VWEN4501 V1
                        WHERE TOTSAL > 8000 AND
                        V1.HIREAGE IN (SELECT MAX(HIREAGE)
                                         FROM VWEN4501 V2
                                         WHERE V2.TOTSAL IS NOT NULL
                                         AND EMPNUM < 2000
                                         GROUP BY HIREAGE
                                         HAVING COUNT(*) IN (2,3)))
    AND EMPNUM BETWEEN 2000 AND 3000
  UNION ALL
    SELECT SERIALNO FROM VWEN4502
      WHERE SERIALNO BETWEEN 2000 AND 3000
      AND EMPLENGTH < ALL (SELECT V2.EMPLENGTH FROM VWEN4502 V2
                             WHERE EMPLENGTH BETWEEN 4000 AND 5000)
  UNION ALL
    SELECT SERIALNO FROM VWEN4502
      WHERE EMPLENGTH *3 < (MONTHSAL/100) + EMPLENGTH
            AND EMPLENGTH BETWEEN 3000 AND 4000
  ORDER BY 1;


-- Count function in a select, insert, update, delete statement

--*STMT1**********************************************
--* VALID DATATYPE: INTEGER
--* KEY POINTS:     COUNT IN BASIC FULLSELECT
SELECT COUNT(DISTINCT INTCOLNN)
FROM TBIPR301
WHERE '0' < RECID;

--*STMT5**********************************************
--* VALID DATATYPE: *
--* KEY POINTS:     COUNT IN BASIC FULLSELECT
SELECT COUNT(*)
FROM VWIPR301
WHERE RECID > '100';

--*STMT10**********************************************
--* VALID DATATYPE: SMALLINT
--* KEY POINTS:     COUNT IN SELECT WITH UNION ALL
SELECT COUNT(DISTINCT INTCOLWDN)
   FROM TBIPR302
UNION ALL
   SELECT COUNT(DISTINCT INTCOLNN)
   FROM VWIPR301
UNION ALL
   SELECT COUNT(DISTINCT INTCOLWDN) FROM TBIPR303;

--*STMT15**********************************************
--* VALID DATATYPE: CHAR
--* KEY POINTS:     COUNT IN SELECT WITH SIMPLE ARITHMETIC
SELECT ((((((COUNT(DISTINCT CHAR1)*2)/2)*10)/10)+9999)-9999)
FROM TBIPR302
WHERE '200' < RECID AND '900' > RECID;

--*STMT30**********************************************
--* VALID DATATYPE: *
--* KEY POINTS:     COUNT IN SELECT WITH VARIOUS
--*                 ARITHMETIC OPERATIONS, CHECK
--*                 LEADING BLANKS (ONLY ONE ROW WHERE
--*                 CHARNN < 'CHARNN' IS TRUE)
SELECT COUNT(*) FROM VWIPR301
WHERE INTEGER((((((SMINT*2)/2)*10)/10)*99.3)/99.3) >
      (SELECT (((((((COUNT(DISTINCT NUMERIC83NN*2)/2)*10)/10)
                          *99)/99)/13)*13)
       FROM TBIPR302
       WHERE CHARNN < 'CHARNN'
      );

--*STMT45**********************************************
--* VALID DATATYPE: TIME
--* KEY POINTS:     COUNT IN SELECT USING GROUP BY
--*                 AND TABLE EXPRESSION, SIMPLE
--*                 ARITHMETIC ON RESULT OF COUNT
SELECT ((((((((COUNT(DISTINCT AVG_SMINT)*2)/2)
                *13.3)/13.3)-25)+25)-33.556)+33.556)
FROM (SELECT AVG(SMINT) AS AVG_SMINT FROM TBIPR302
WHERE TIME(TIME(CHAR(TIME1))) < '17.58.58'
GROUP BY CHAR1) AS TBL;

--*STMT55**********************************************
--* VALID DATATYPE: CHAR,DATE
--* KEY POINTS:     COUNT WITH CORRELATED REFS, UNION
--*                 AND UNION ALL
SELECT COUNT(DISTINCT V1.DATE1)
FROM VWIPR301 AS V1
   UNION
SELECT COUNT(DISTINCT T1.RECID)
FROM TBIPR303 AS T1
   UNION ALL
SELECT COUNT(DISTINCT T2.CHAR1)
FROM TBIPR301 AS T2
UNION
SELECT COUNT(DISTINCT V2.CHARWDU)
FROM VWIPR301 AS V2
UNION ALL
SELECT COUNT(DISTINCT T3.TIMESTAMP2)
FROM TBIPR302 AS T3;

--*STMT60*********************************************
--* VALID DATATYPE: DOUBLE PRECISION
--* KEY POINTS:     COUNT WITH CASE, SHOULD GO TO ELSE
SELECT
CASE
   WHEN COUNT(DISTINCT DOUBLE1) = 23 THEN 99999
   WHEN COUNT(*) =  24 THEN 88888
   WHEN COUNT(DISTINCT DOUBLE1) = 25 THEN 77777
   ELSE 10000
END
FROM TBIPR302;

--*STMT75*********************************************
--* VALID DATATYPE: *
--* KEY POINTS:     COUNT IN DEEPLY NESTED SUBSELECT
--*                 WITH SOME ARITHMETIC
SELECT * FROM (
  SELECT * FROM (
     SELECT * FROM (
        SELECT * FROM (
           SELECT * FROM (
              SELECT * FROM (
                 SELECT * FROM (
                   SELECT ((((((((((COUNT(*)
                      *2)/2)*10)/10)*1.5)*1.6)*1.7)*0.8)/10)-0.6)
                    FROM TBIPR301
                    WHERE RECID < '400'
                 ) AS TBLEXP6
              ) AS TBLEXP5
           ) AS TBLEXP4
        ) AS TBLEXP3
     ) AS TBLEXP2
  ) AS TBLEXP1
) AS TBLEXP0;


-- Day of week function in a select, insert, update, delete statement

--*STMT35********************************************
--* VALID DATATYPE:  CHAR, DATE, TIMESTAMP
--* KEY POINTS:      DAYOFWEEK, DAYOFMONTH, DAYOFYEAR FUNCTIONS
--*                  IN SELECT AND WHERE CLAUSE OF SUBSELECT
--*                  (2 LEVELS)
SELECT DAY('2000-01-01')/DAYOFYEAR('2000-01-01')
FROM VWKT0902
WHERE RECID = FILENO
  AND DAYOFWEEK(DATE1) IN
      (SELECT DAYOFWEEK(DATE1)
       FROM TBKT0901
       WHERE RECID = CHAR(100)
         AND DAYOFMONTH(TIMESTMP) <>
             (SELECT DAYOFYEAR(TIMESTMP)
              FROM TBKT0902
              WHERE DAYOFWEEK(DATE2) <= DAYOFYEAR(DATE2)
                AND RECID = CHAR('100')));

--*STMT40********************************************
--* VALID DATATYPE:  CHAR, VARCHAR, DATE, TIMESTAMP
--* KEY POINTS:      DAYOFWEEK, DAYOFMONTH, DAYOFYEAR FUNCTIONS
--*                  IN SELECT/FROM/WHERE CLAUSE OF
--*                  NESTED TABLE EXPRESSION AND SUBSELECT
--*                  WITH CORRELATED QUERY
SELECT DAYOFMONTH(VARCHAR('2000-01-01'))/DAYOFYEAR(CHAR('2000-01-01'))
FROM (SELECT A.RECID, B.FILENO, A.DATE1, B.TIMESTMP, A.DATE2
              FROM VWKT0902 A, TBKT0901 B
              WHERE A.RECID = B.FILENO
                AND DAYOFMONTH(A.DATE1) <>
                    DAYOFYEAR(VARCHAR(A.DATE1))
                AND DAYOFWEEK(CURRENT TIMESTAMP) < 8) AS TBKT09T1
WHERE RECID = FILENO
  AND DAYOFWEEK(DATE1) IN
      (SELECT DAYOFWEEK(DATE1)
       FROM TBKT0901
       WHERE RECID = CHAR(100)
         AND DAYOFMONTH(VARCHAR(TIMESTMP)) <>
             (SELECT DAYOFYEAR(VARCHAR(TIMESTMP))
              FROM TBKT0902
              WHERE DAYOFWEEK(DATE2) <= DAYOFYEAR(DATE2)
                AND RECID = CHAR('100')));

--*STMT50*********************************************
--* VALID DATATYPE:  CHAR, VARCHAR, DATE, TIMESTAMP
--* KEY POINTS:      DAYOFWEEK, DAYOFMONTH, DAYOFYEAR FUNCTIONS
--*                  IN SELECT/FROM/WHERE CLAUSE OF
--*                  NESTED TABLE EXPRESSION WITH CORRELATED QUERY
--*                  AND IN SEARCHED-WHEN CLAUSE OF CASE STMT
SELECT DAYOFMONTH(VARCHAR('2000-01-01'))/DAYOFYEAR(CHAR('2000-01-01'))
FROM (SELECT A.RECID, B.FILENO, A.DATE1, B.TIMESTMP, A.DATE2
              FROM VWKT0902 A, TBKT0901 B
              WHERE A.RECID = B.FILENO
                AND DAYOFMONTH(A.DATE1) <>
                    DAYOFYEAR(VARCHAR(A.DATE1))
                AND DAYOFWEEK(CURRENT TIMESTAMP) < 8) AS TBKT09T1
WHERE CASE
        WHEN DAYOFWEEK(DATE1)
          =  DAYOFMONTH(CHAR(TIMESTMP))         THEN 0
        WHEN DAYOFMONTH(VARCHAR(DATE1))
          =  DAYOFYEAR(TIMESTMP)                THEN 1
        WHEN DAYOFWEEK(VARCHAR(DATE1))
          =  DAYOFYEAR(CHAR('2000-01-01'))      THEN 2
        WHEN DAYOFWEEK(DATE1)
          =  DAYOFWEEK(CURRENT DATE)            THEN DAYOFWEEK(DATE1)
        WHEN DAYOFWEEK(CHAR(DATE1))
          <  DAYOFWEEK(CHAR(CURRENT TIMESTAMP)) THEN DAYOFMONTH(DATE1)
        WHEN DAYOFWEEK(VARCHAR(DATE1))
          >  DAYOFWEEK(VARCHAR(CURRENT DATE))   THEN DAYOFYEAR(DATE1)
      ELSE 999 END <= 356;

--*STMT55*********************************************
--* VALID DATATYPE:  CHAR, VARCHAR, DATE, TIMESTAMP
--* KEY POINTS:      DAYOFWEEK, DAYOFMONTH, DAYOFYEAR FUNCTIONS
--*                  IN SELECT/FROM/WHERE CLAUSE OF FULLSELECT
--*                  WITH SEARCHED-WHEN CLAUSE OF CASE STMT AND USE
--*                  CASE STMT AS ARGUMENT TO CHAR
SELECT DAYOFMONTH(VARCHAR('2000-01-01'))/DAYOFYEAR(CHAR('2000-01-01'))
FROM VWKT0902 A, TBKT0901 B
WHERE A.RECID = B.FILENO
  AND DAYOFMONTH(CASE
        WHEN DAYOFWEEK(A.DATE1)
          =  DAYOFMONTH(CHAR(B.TIMESTMP))         THEN '2000-01-01'
        WHEN DAYOFMONTH(VARCHAR(A.DATE1))
          =  DAYOFYEAR(B.TIMESTMP)                THEN '2000-01-02'
        WHEN DAYOFWEEK(VARCHAR(A.DATE1))
          =  DAYOFYEAR(CHAR('2000-01-01'))        THEN '2000-01-03'
        WHEN DAYOFMONTH(B.DATE1)
          =  DAYOFMONTH(CURRENT DATE)             THEN '2000-01-04'
        WHEN DAYOFMONTH(CHAR(B.DATE1))
          <  DAYOFMONTH(CHAR(CURRENT TIMESTAMP))  THEN '2000-01-05'
        WHEN DAYOFMONTH(VARCHAR(A.DATE1))
          >  DAYOFMONTH(VARCHAR(CURRENT DATE))    THEN '2000-01-06'
      ELSE ('2000-01-07') END) < 7
  AND DAYOFYEAR(CASE
        WHEN DAYOFWEEK(A.DATE1)
          =  DAYOFMONTH(CHAR(B.TIMESTMP))         THEN '2000-01-01'
        WHEN DAYOFMONTH(VARCHAR(A.DATE1))
          =  DAYOFYEAR(B.TIMESTMP)                THEN '2000-01-02'
        WHEN DAYOFWEEK(VARCHAR(A.DATE1))
          =  DAYOFYEAR(CHAR('2000-01-01'))        THEN '2000-01-03'
        WHEN DAYOFYEAR(B.DATE1)
          =  DAYOFYEAR(CURRENT DATE)              THEN '2000-01-04'
        WHEN DAYOFYEAR(CHAR(B.DATE1))
          <  DAYOFYEAR(CHAR(CURRENT TIMESTAMP))   THEN '2000-01-05'
        WHEN DAYOFYEAR(VARCHAR(A.DATE1))
          >  DAYOFYEAR(VARCHAR(CURRENT DATE))     THEN '2000-01-06'
      ELSE ('2000-01-07') END) < 7
  AND DAYOFWEEK(CASE
        WHEN DAYOFWEEK(A.DATE1)
          =  DAYOFMONTH(CHAR(B.TIMESTMP))         THEN '2000-01-02'
        WHEN DAYOFMONTH(VARCHAR(A.DATE1))
          =  DAYOFYEAR(B.TIMESTMP)                THEN '2000-01-03'
        WHEN DAYOFWEEK(VARCHAR(A.DATE1))
          =  DAYOFYEAR(CHAR('2000-01-01'))        THEN '2000-01-04'
        WHEN DAYOFWEEK(B.DATE1)
          =  DAYOFWEEK(CURRENT DATE)              THEN '2000-01-05'
        WHEN DAYOFWEEK(CHAR(B.DATE1))
          <  DAYOFWEEK(CHAR(CURRENT TIMESTAMP))   THEN '2000-01-06'
        WHEN DAYOFWEEK(VARCHAR(A.DATE1))
          >  DAYOFWEEK(VARCHAR(CURRENT DATE))     THEN '2000-01-07'
      ELSE ('2000-01-01') END) < 7;


-- Inner Joins

--**    - COMMA join 2 FULL joins;
--** delete
SELECT TBNN1200.old_offices.OLD_OFFICE, TBNN1200.old_offices.EMP_ID
FROM (TBNN1200.old_offices T1 FULL JOIN TBNN1200.new_offices T2
ON T1.emp_id = T2.emp_id),
(TBNN1200.old_offices T3 FULL JOIN TBNN1200.new_offices T4
ON T3.emp_id = T4.emp_id)
WHERE T1.emp_id = T3.emp_id;

SELECT TBNN1201.old_offices.OLD_OFFICE, TBNN1201.old_offices.EMP_ID
FROM (TBNN1201.old_offices T1 FULL JOIN TBNN1201.new_offices T2
ON T1.emp_id = T2.emp_id),
(TBNN1201.old_offices T3 FULL JOIN TBNN1201.new_offices T4
ON T3.emp_id = T4.emp_id)
WHERE T1.emp_id = T3.emp_id;


-- Outer Joins(DML)

 SELECT EMP_NAME, O.OLD_OFFICE, O.NEW_OFFICE
   FROM OUTERJN.EMPLOYEES INNER JOIN
        (SELECT OLD_OFFICE, NEW_OFFICE,
                VALUE (OUTERJN.OLD_OFFICES.EMP_ID,
                       OUTERJN.NEW_OFFICES.EMP_ID) AS E_ID
           FROM OUTERJN.OLD_OFFICES RIGHT JOIN OUTERJN.NEW_OFFICES
             ON OUTERJN.OLD_OFFICES.EMP_ID = OUTERJN.NEW_OFFICES.EMP_ID)
        AS O
     ON OUTERJN.EMPLOYEES.EMP_ID = O.E_ID;

 SELECT EMP_NAME, OUTERJN.EMPLOYEES.EMP_ID, NEW_OFFICE
   FROM OUTERJN.EMPLOYEES, OUTERJN.NEW_OFFICES
      WHERE OUTERJN.EMPLOYEES.EMP_ID = OUTERJN.NEW_OFFICES.EMP_ID
 UNION ALL
 SELECT EMP_NAME, EMP.EMP_ID, '?'
   FROM OUTERJN.EMPLOYEES EMP
      WHERE EXISTS
         (SELECT * FROM OUTERJN.NEW_OFFICES X
            WHERE EMP.EMP_ID = X.EMP_ID);

 SELECT EMP_NAME, OUTERJN.EMPLOYEES.EMP_ID, NEW_OFFICE
   FROM OUTERJN.EMPLOYEES LEFT JOIN OUTERJN.NEW_OFFICES
     ON OUTERJN.EMPLOYEES.EMP_ID = OUTERJN.NEW_OFFICES.EMP_ID;

 SELECT PART, SUPPLIER, OUTERJN.PARTS.PROD#, PRODUCT
   FROM OUTERJN.PARTS LEFT OUTER JOIN OUTERJN.PRODUCTS_NOTNULL
     ON OUTERJN.PARTS.PROD# = OUTERJN.PRODUCTS_NOTNULL.PROD#
        WHERE OUTERJN.PARTS.PROD# > 100;

 SELECT OUTERJN.MANYTYPES.*, OUTERJN.MANYTYPES_NOTNULL.*
   FROM OUTERJN.MANYTYPES LEFT JOIN OUTERJN.MANYTYPES_NOTNULL
     ON OUTERJN.MANYTYPES.DEC62COL = OUTERJN.MANYTYPES_NOTNULL.DEC72COL
        WHERE OUTERJN.MANYTYPES.INTCOL BETWEEN 5 AND 15
  ORDER BY 1;

 SELECT OUTERJN.MANYTYPES.*, OUTERJN.MANYTYPES_NOTNULL.*
   FROM OUTERJN.MANYTYPES RIGHT JOIN OUTERJN.MANYTYPES_NOTNULL
     ON OUTERJN.MANYTYPES.DEC62COL = OUTERJN.MANYTYPES_NOTNULL.DEC72COL
        WHERE OUTERJN.MANYTYPES_NOTNULL.INTCOL > 18
  ORDER BY 1,11;

--* Example from the spec, made into left join                         *
SELECT EMP_NAME, O.OLD_OFFICE, O.NEW_OFFICE
  FROM OUTERJN.EMPLOYEES INNER JOIN
       (SELECT OLD_OFFICE, NEW_OFFICE,
               VALUE (OUTERJN.OLD_OFFICES.EMP_ID,
                      OUTERJN.NEW_OFFICES.EMP_ID) AS E_ID
          FROM OUTERJN.NEW_OFFICES LEFT JOIN OUTERJN.OLD_OFFICES
            ON OUTERJN.OLD_OFFICES.EMP_ID = OUTERJN.NEW_OFFICES.EMP_ID)
       AS O
    ON OUTERJN.EMPLOYEES.EMP_ID = O.E_ID;

--* Example from the spec, old method for left join                    *
SELECT EMP_NAME, OUTERJN.EMPLOYEES.EMP_ID, NEW_OFFICE
  FROM OUTERJN.EMPLOYEES, OUTERJN.NEW_OFFICES
     WHERE OUTERJN.EMPLOYEES.EMP_ID = OUTERJN.NEW_OFFICES.EMP_ID
UNION ALL
SELECT EMP_NAME, EMP.EMP_ID, '?'
  FROM OUTERJN.EMPLOYEES EMP
     WHERE EXISTS
        (SELECT * FROM OUTERJN.NEW_OFFICES X
           WHERE EMP.EMP_ID = X.EMP_ID);

  SELECT *
    FROM OUTERJN.TEMPTAB1 T1 LEFT JOIN OUTERJN.TEMPTAB3 T2
      ON T1.COL1 = T2.COL1;



-- Subselects in a select, insert, update, delete statement

SELECT intcol, charcol FROM TBLV0100.manytypes_ctrl
WHERE intcol in (
SELECT t1.intcol
FROM
((((TBLV0100.mtypes_1 T1 FULL JOIN TBLV0100.mtypes_2 T2
ON T1.charcol = T2.vcharcol AND T1.intcol = T2.dec62col)
FULL JOIN
(TBLV0100.mtypes_2 T4 FULL JOIN TBLV0100.mtypes_1 T3
ON T4.smintcol = T3.dec62col)
ON T1.intcol = T4.intcol AND T2.charcol = T3.charcol)
FULL JOIN
((TBLV0100.mtypes_1 T5 FULL JOIN TBLV0100.mtypes_2 T6
ON T5.charcol = T6.vcharcol AND T5.intcol = T6.dec62col)
FULL JOIN
(TBLV0100.mtypes_2 T7 FULL JOIN TBLV0100.mtypes_1 T8
ON T7.smintcol = T8.dec62col)
ON T5.intcol = T8.dec62col AND T6.charcol = T7.charcol)
ON T5.dec62col = T1.dec62col AND T5.intcol = T3.intcol)
FULL JOIN
(((TBLV0100.mtypes_1 T9 FULL JOIN TBLV0100.mtypes_2 T10
ON T9.charcol = T10.vcharcol AND T9.intcol = T10.dec62col)
FULL JOIN
(TBLV0100.mtypes_2 T12 FULL JOIN TBLV0100.mtypes_1 T11
ON T12.smintcol = T11.dec62col)
ON T9.intcol = T12.intcol AND T10.charcol = T11.charcol)
FULL JOIN
((TBLV0100.mtypes_1 T13 FULL JOIN TBLV0100.mtypes_2 T14
ON T13.charcol = T14.vcharcol AND T13.intcol = T14.dec62col)
FULL JOIN
(TBLV0100.mtypes_2 T15 FULL JOIN TBLV0100.mtypes_1 T16
ON T15.smintcol = T16.dec62col)
ON T13.intcol = T16.dec62col AND T14.charcol = T15.charcol)
ON T13.dec62col = T9.dec62col AND T13.intcol = T11.intcol)
ON T12.dec62col = T2.dec62col AND T14.intcol = T8.intcol)
FULL JOIN
((((TBLV0100.mtypes_1 T17 FULL JOIN TBLV0100.mtypes_2 T18
ON T17.charcol = T18.vcharcol AND T17.intcol = T18.dec62col)
FULL JOIN
(TBLV0100.mtypes_2 T20 FULL JOIN TBLV0100.mtypes_1 T19
ON T20.smintcol = T19.dec62col)
ON T17.intcol = T20.intcol AND T18.charcol = T19.charcol)
FULL JOIN
((TBLV0100.mtypes_1 T21 FULL JOIN TBLV0100.mtypes_2 T22
ON T21.charcol = T22.vcharcol AND T21.intcol = T22.dec62col)
FULL JOIN
(TBLV0100.mtypes_2 T23 FULL JOIN TBLV0100.mtypes_1 T24
ON T23.smintcol = T24.dec62col)
ON T21.intcol = T24.dec62col AND T22.charcol = T23.charcol)
ON T21.dec62col = T17.dec62col AND T21.intcol = T19.intcol)
FULL JOIN
(((TBLV0100.mtypes_1 T25 FULL JOIN TBLV0100.mtypes_2 T26
ON T25.charcol = T26.vcharcol AND T25.intcol = T26.dec62col)
FULL JOIN
(TBLV0100.mtypes_2 T28 FULL JOIN TBLV0100.mtypes_1 T27
ON T28.smintcol = T27.dec62col)
ON T25.intcol = T28.intcol AND T26.charcol = T27.charcol)
FULL JOIN
(TBLV0100.mtypes_1 T29 FULL JOIN TBLV0100.mtypes_2 T30
ON T29.charcol = T30.vcharcol AND T29.intcol = T30.dec62col)
ON T29.dec62col = T25.dec62col AND T29.intcol = T27.intcol)
ON T28.dec62col = T18.dec62col AND T30.intcol = T24.intcol)
ON T28.dec62col = T2.dec62col AND T30.intcol = T14.intcol)
ORDER BY 1;


-- Union / Union ALL

 SELECT GR1,COUNT(*)
        FROM USRT027.SORTTAB1 WHERE INT1 < 20092401
        GROUP BY GR1
    UNION
 SELECT GR2,COUNT(*)
        FROM USRT027.SORTTAB2 WHERE INT2 < 20092401
        GROUP BY GR2
        HAVING COUNT(*) > 10
    UNION
 SELECT MIN(GR1),COUNT(DISTINCT FLT1)
        FROM USRT027.SORTTAB1
    UNION
 SELECT MAX(USRT027.SORTTAB1.GR1), MIN(USRT027.SORTTAB2.INT2)
        FROM USRT027.SORTTAB2,USRT027.SORTTAB1
 ORDER BY 1;


    SELECT YEAR(EMENDATE), MONTH(EMENDATE), DAY(EMENDATE),
           HOUR(EMPTIME), MINUTE(EMPTIME), SECOND(EMPTIME),
           MICROSECOND(EMPTIME)
           FROM USRT029.EMPROJACT
           WHERE DEPTNO ='M10'
             AND EMENDATE IS NOT NULL
             AND     PROJNO = '973'
    UNION
    SELECT YEAR(EMSTDATE), MONTH(EMSTDATE), DAY(EMSTDATE),
           HOUR(EMPTIME), MINUTE(EMPTIME), SECOND(EMPTIME),
           MICROSECOND(EMPTIME)
           FROM USRT029.EMPROJACT
           WHERE EMENDATE IS NOT NULL
           AND DEPTNO ='S33'
    UNION
    SELECT YEAR(EMSTDATE), MONTH(EMSTDATE), DAY(EMSTDATE),
           HOUR(EMPTIME), MINUTE(EMPTIME), SECOND(EMPTIME),
           MICROSECOND(EMPTIME)
           FROM USRT029.EMPROJACT
           WHERE DEPTNO = ( SELECT MAX(DEPTNO)
              FROM USRT029.EMPROJACT );


    SELECT SUBSTR(COUNTRY,1,3), LENGTH(EMPNO), DIGITS(JOBCODE),
           VALUE(SRATE,1)
           FROM USRT029.EMPINT
           WHERE EMPNO <= '062000'
    UNION ALL
    SELECT COUNTRY, EDUC, EMPLOC, SAL
           FROM USRT029.EMPINT
           WHERE ((SRATE * EDUC) - 5 = 190)
    UNION ALL
    SELECT SUBSTR(A.SEX,1,1),A.JOBCODE, SUBSTR(B.LOCNAME,1,2),
           VALUE(A.JOBCODE,1)
           FROM USRT029.EMPINT A,
                USRT029.EMPLOC B
           WHERE (B.CITY LIKE '%NAGAWA%' AND A.EMPNO = '069000')
    UNION ALL
    SELECT SUBSTR(COUNTRY,1,5), LENGTH(EMPNO), DIGITS(JOBCODE),
           VALUE(SRATE,1)
           FROM USRT029.EMPINT
           WHERE EMPNO <= '062000';


    SELECT HEX(A.EMPNO), DECIMAL(A.SRATE), INTEGER(A.EDUC)
           FROM USRT029.EMPINT A
           WHERE A.SRATE > (A.EDUC * 2 )
             AND A.EMPNO IN (SELECT A.EMPNO
                               FROM USRT029.EMPINT A
                               WHERE A.DEPTNO =
                                     ANY(SELECT A.DEPTNO
                                           FROM USRT029.EMPINT A
                                           WHERE A.DEPTNO NOT BETWEEN
                                                     'Y10' AND 'Y79'))
    UNION ALL
       (SELECT  A.EMPLOC, A.JOBCODE, A.EDUC
                FROM USRT029.EMPINT A
                WHERE A.SAL = 004900.00
                   OR (A.EDUC = A.SRATE / 2 - 19)
        UNION ALL
          (SELECT HEX(A.EMPLOC), INTEGER(A.JOBCODE),
                  DECIMAL(A.SAL)
                  FROM USRT029.EMPINT A
                  WHERE A.DEPTNO = 'Y55'
           UNION
           SELECT HEX(A.BORN), A.EDUC, INTEGER(A.JOBCODE)
                  FROM USRT029.EMPINT A
                  WHERE A.SRATE = (SELECT COUNT(*) + 6
                      FROM USRT029.EMPINT A)));


    (SELECT CHAR(EMSTDATE), CHAR(EMENDATE),
            DATE(DAYS('02/20/1601') - DAYS('01/20/1601')),
           CHAR(TIME(EMPTIME))
           FROM USRT029.EMPROJACT
           WHERE EMENDATE IS NOT NULL
           AND PROJNO BETWEEN '104' AND '392'
           AND YEAR(EMENDATE) = 1979
     UNION
      ( SELECT CHAR(EMSTDATE, ISO), CHAR(EMENDATE, EUR),
               DATE(EMSTDATE), CHAR(TIME(EMPTIME), ISO)
               FROM USRT029.EMPROJACT
               WHERE ACTNO = 500
        UNION ALL
        SELECT CHAR(EMSTDATE, EUR), CHAR(EMENDATE, ISO),
               DATE(EMSTDATE),CHAR(TIME(EMPTIME), ISO)
               FROM USRT029.EMPROJACT
               WHERE ACTNO = 500
                 AND PROJNO = '393'
                 AND YEAR(EMSTDATE) = 1601
                 AND EMENDATE IS NOT NULL ) )
    UNION ALL
    SELECT CHAR(EMSTDATE), CHAR(EMENDATE),
           DATE(DAYS('1601-02-20') - DAYS('1601-01-20')),
           CHAR(TIME(EMPTIME))
           FROM USRT029.EMPROJACT
           WHERE EMENDATE IS NOT NULL
             AND PROJNO BETWEEN '007' AND '100'
             AND EMPNO IN (SELECT EMPNO
                                  FROM USRT029.EMPROJACT
                                  WHERE EMPTIME -
                                    TIMESTAMP('1970-6-17-2.00.00') = 0);




-- WITH Statement

with agents(name, salary) as 
	((select name, salary
	  from fedemp
	  where manager = 'Hoover')
	 union all
	 (select f.name, f.salary
	  from agents as a, fedemp as f
	  where f.manager = a.name)
	),
      innerjoin(name, rank, subject, enrollment) as 
	(select t.name, t.rank, c.subject, c.enrollment
	 from teachers as t, courses as c
	 where t.name = c.teacher and c.quarter = 'Fall 96'),
      teacher_only(name, rank) as 
	(select name, rank
	 from teachers
	except all
	 select name, rank
	 from innerjoin),
      course_only(subject, enrollment) as
	(select subject, enrollment
	 from courses
	 where quarter = 'Fall 96'
	except all
	 select subject, enrollment
	 from innerjoin)
select name, rank, subject, enrollment
from innerjoin
union all
select name, rank, cast(null as varchar(20)) as subject, cast(null as integer) as enrollment
from teacher_only
union all
select cast(null as varchar(20)) as name, cast(null as varchar(20)) as rank, subject, enrollment
from course_only;

-- Alias name error.
select (select * from cl_sched union select * from cl_sched) 
	from department;
	





